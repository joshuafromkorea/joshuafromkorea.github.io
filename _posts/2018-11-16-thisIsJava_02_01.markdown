---
layout: post
title: "이것이 자바다 self study - chapter 2"
date: 2018-11-16
categories:
---
오늘은 2019년 2월 6일, 설 연휴의 마지막날이다. 그동안 블로그에 업로드 하지않고 모아두었던 공부한 것들을 올리는 것이 5일짜리 설날 연휴기간의 목표였다. 다만 첫날에 진행하려고 했는데, 이번 연휴내내 4일간 일을 하냐고 이제서야 올리게 되었다.

작년 11월 초, 큰맘 먹고 블로그를 개시하면서 시작한 _This is Java_ self-study는 사실 12월 중순경에 1권을 마무리 지었다. 근데 자바 책 앞부분이야 뭐 쭉쭉 진도가 빠지기도 했고, 당시만해도 2-3과 정도 더 완료하면 업로드해야지 맘먹었었다. markdown 파일 하나에 쭉 작성하다보니깐 블로그에 올리려면 분리를 해야하는 것도 귀찮았고...

당시에는 분명히 한 챕터를 끝낼때마다 해당 챕터에 언제 마무리지었는지 적도록 해서 업로드할 때 날짜를 바꿔서 올릴 수 있게 하려고 했는데, 아마도 Chapter 2가 마지막으로 그렇게 적어놓은 것인듯.... 그래도 덕분에 3달 가량 지난뒤에 올림에도 일단 블로그에는 공부한 날짜에 맞춰서 올릴 수 있다. 모아서 올리다보니깐 각 챕터별로 넋두리나 해야지.. 읽는사람도 없고, 날짜 없으면 대충 끼워 맞추고..

## Chapter 2 변수와 타입

변수와 타입챕터는 아는내용만 간단하게 정리하고 넘어간다. 확실히 몰랐던 것만 강조하는 방식으로 서술

### 2.1 변수

* 변수란 하나의 값을 저장하는 메모리 공간
* 변수는 선언문을 사용한다 (`int a;`)
* **숫자로 시작할 수 없다**, `$`,`_`는 가능하다
* 자바예약어는 사용할 수 없다.

#### 2.1.3 변수의 사용

##### 변수값 저장: 대입연산자 `=`를 사용

* Literal: 소스코드내에 직접 입력된 값
  * 정수 리터럴
    * 소수점이 없으면 10진수
    * 0으로 시작하면 8진수
    * 0x로 시작하면 16진수 (대소문자 a~F)
  * 실수 리터럴
    * 소수점이 있으면 10진수 실수
    * 영문자 E(e)가 있으면 10진수 __지수__와 __가수__
  * 문자리터럴: `''`, 역슬래쉬(`\`) 와 함께 쓰이면 이스케이프 문자라는 특수한 리터럴
  * 문자열 리터럴: `""`
  * 논리리터럴: `true`,`false`

##### 변수값 읽기

초기화가 되어야만 읽을 수 있다.

#### 2.1.4 변수의 사용 범위 (scope)

모든 변수는 중괄호 (`{}`) 안에서만 **선언**되고 **사용**된다. 메서드 안에서 선언이되면 **local 변수**라고 부른다. 또한

> 변수는 선언된 블록 내에서만 사용 가능하다.

변수 사용위치를 잘 생각하고, 범위를 맞추어서 선언하는 것이 중요하다.

### 2.2 데이터 타입

모든 변수에는 타입이 있으며, 해당 타입은 **변경 불가능** 하다 .

#### 2.2.1 기본(원시: primitive) 타입

리터럴을 직접 저장하는 타입을 말한다. 

#### 2.2.2 정수타입

정수타입은 총 4가지로 메모리 크기가 아래와 같다. 일반적인 정수연산에는`int` 타입을 사용한다.

| 정수타입     | `byte` | `char` | `short` | `int` | `long` |
| ------------ | ------ | ------ | ------- | ----- | ------ |
| **바이트수** | 1      | 2      | 2       | 4     | 8      |

* **`byte`타입**: 색상 정보 및 파일등의 이진데이터 처리
  * -128~127 (-2<sup>7</sup> ~ 2<sup>7</sup>-1)
  * MSB는 부호로 사용 (1일 경우 음수)
  * 음수는 **2의 보수**로 표현된다.
* **`char`타입**: 모든 문자는 유니코드로 처리한다.
  * 0~65535 범위의 2byte 정수 값에 문자를 매치
  * 유니코드에는 음수범위가 없기 때문에 char에는 음수를 저장할 수 없다.
  * 정수 리터럴( 10진수, 16진수 다 가능)로 입력 가능
  * 빈문자는 반드시 공백(`' '`)을 포함해야 한다 (unicode : 32)
* **`short`타입**: 16bit 정수 저장하는 값으로 C언어 호환을 위해서만 사용
* **`int`타입**: **Java의 모든 연산은 `int` 타입으로 변환**되어 연산된다. 4byte를 사용하여 -2<sup>31</sup> ~ 2<sup>31</sup>-1 범위를 가진다.
* **`long`타입**: 8byte를 사용하며, 은행 및 우주와 관련된 큰 수를 다루는 프로그램에 사용
  * 컴파일러에게 정수 리터럴이 8byte임을 알리기 위해서 `L`을 리터럴 뒤에 붙여줄 수 있다.
  * 특히, int타입의 저장범위를 벗어나는 경우엔 `l`이나 `L`을 쓰지 않으면 컴파일 에러가 난다.

#### 2.2.3 실수 타입(`float`, `double`)

| 실수타입 | `float`             | `double` (더 정밀한 값이 가능) |
| -------- | ------------------- | ------------------------------ |
| 비트수   | 1+8+23 = 32 (4byte) | 1+11+52 = 64 (8byte)           |

`float`과 `double`은 값을 표현하는 방식이 정수타입과 다르기 때문에 훨씬 더 큰 범위의 값을 저장할 수 있다.

##### 부동 소수점(floating-point)방식

Java에서 실수를 저장하는 방식으로, 세가지 파트로 나뉜다.

* 부호: 1bit를 사용한다
* **가수**(mantissa):  0 ≤ m 1 범위의 실수 (많은 bit)
* **지수**(exponent): 10<sup>n</sup>에서 **n**에 해당하는 수 (적은 bit)

> Java는 실수 리터럴의 기본을 `double`로 간주한다...(중략)... 실수 리터럴을 `float`에 저장하기 위해선 `F`,`f`를 뒤에 붙여주어야 한다.

또한, 정수 리터럴 중, 10의 지수를 나타내는 `E`또는 `e`가 포함된 경우 실수 타입 변수에 저장해야 한다.

#### 2.2.4 논리타입(`boolean`)

1byte를 사용하며, `true`와 `false`두 상태 값만 저장 가능하다.

### 2.3 타입 변환

#### 2.3.1 자동 타입 변환 (Promotion)

Runtime에서 자동적으로 타입변환이 일어난다, 작은크기 타입이 큰크기타입에 저장될 때 가능하다. 정수와 실수타입의 크기비교는 아래와 같다

> `byte` (1) < `short`(2) < `int`(4) < `long`(8) < `float`(4) < `double`(8)

크기 비교는 byte수보다 표현할 수 있는 값을 기준을 한다. 

##### 자동 타입 변환 예외 케이스 : `char`

char 타입은 더 큰 타입으로 변환되면 유니코드 값이 해당 타입에 저장된다. **단** `char` 타입이 음수를 저장할 수 없음으로 `byte`타입을 `char`로 자동 변환 시킬 수 없다.

#### 2.3.2 강제 타입 변환 (Casting)

큰 타입을 작은 타입으로 변환할 때는 캐스팅 연산자 `(타입명)`을 사용하는데,  강제적으로 작은 크기로 변환 할 경우 원래 값이 보존되지 않을 수 있다. 예는 아래와 같다.

```java
int intVal = 103029770;
byte byteVal = (byte) intval; //강제 변환은 되지만 원래 int값 중 마지막 byte만 보존된다.
System.out.println(byteval); // 10
```
`int`타입은 `char`로 자동변환(promotion) 되지 않기 때문에 casting이 필요하다

```java
int intVal = 'A'; //intVal 에 65가 저장됨
char charVal = (char) intVal;
```

실수 타입은 항상 정수타입보다 크다고 여겨지므로,  자동변환(promotion) 되지 않아, casting 이 필요하다

```java
double doubleVal = 3.14;
int intVal = (int)doubleVal; //정수 부분인 3만 저장된다.
```

안전하게 값이 보존될 수 있는지 검사할 수 있는 방법으로는, 변환학자 하는 타입의 `MIN_VALUE`와 `MAX_VALUE`를 사용하여 검증하는 것이다. Java는 `char`와 `boolean`을 제외하고 primitive타입에 대한 최대, 최소 값을 상수로 제공하고 있다. 예시는 아래와 같다.

```java
if((intValue<Byte.MIN_VALUE)||(intValue>Byte.MAX_VALUE)){
	//해당 범위에 벗어나는 경우 casting하지 않는다.
}else{
    byte byteValue = (byte) intValue;
}
```

또한 정수를 실수로 변환(promotion)하는 경우엔, 실수의 가수 비트로 표현가능한 값이어야지 정밀도가 유지된다. 그렇지 않을 경우 **근사치**가 저장되기 때문에, 다시 정수로 변환(Casting)시에 같은 값을 얻지 않을 수 있다.

> `int`의 크기는 32비트이므로 `double`의 가수 52비트 보다는 작기 때문에, 어떠한 `int`값이라도 안전하게 정밀도 손실 없이 `double`타입으로 변환될 수 있다.

#### 2.3.3 연산식에서의 자동 타입 변환

* 피연산자중 큰 타입으로 변환되어 연산된다
  * 정수, 실수 리터럴간의 연산은 결과가 실수로 나온다.
* 정수 연산일 경우: `int` 타입을 기본으로 한다 = 연산결과는 `int`타입이 된다.
  * 따라서 `char`타입의 연산결과는 반드시 `(char)`로 캐스팅 하여야 한다.
  * 피연산자중 하나이상이 `long`인 경우엔 피연산자와 결과모두 `long`으로 변환된다.
* 실수 연산의 경우: `float`과 `float`간의 연산을 제외하고, 실수 리터럴이나 `double`이 포함되면 `double`타입을 기본으로 한다. 
