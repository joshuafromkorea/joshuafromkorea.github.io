---
layout: post
title: "이것이 자바다 self study - chapter 8"
date: 2018-12-09
categories:
---

매번 블로그에 글을 올리려고 회사컴퓨터에 있던 정리된 파일을 옮겨야 한다고 생각했는데 현재 프로젝트 수행중이라 (오늘은 3월 1일..) 못하다가 어제 야근 후 퇴근전에 생각나서 옮겼다. 근데 그마저도 11챕터부분은 뺴먹고 옮긴....

조금 성장했다고 느꼈던 인터페이스 챕터, 당시 병행해서 공부하고 있던 toby의 스프링과 같이 보면서 인터페이스라는 이름에 대한 이해에서부터, 그로인해서 인터페이스를 사용하고 만들때 어떤점을 생각해야 하는지 알아야 하는 챕터였다.

---

## Chapter 8 인터페이스
### 8.1 인터페이스의 역할
>  자바에서 인터페이스(interface)는 객체의 사용 방법을 정의한 타입이다. 

개발자의 코드와 객체가 서로 통신하는 접점 역할의 의미에서 인터페이스라는 이름으로 생각하면 된다. 즉 개발자의 코드는 객체의 내부 구조를 알 필요가 없고, 인터페이스의 메소드만 알고 있으면 된다. 이렇기 때문에 동일한 인터페이스를 구현한 객체를 언제든지 개발 코드의 수정 없이 교체할 수 있다.

### 8.2 인터페이스 선언

> 물리적 형태는 클래스와 동일하다.

#### 8.2.1 인터페이스 선언

`class`키워드 대신에 `interface` 키워드를 사용하면 된다. 인터페이스의 구성멤버는 클래스와 달리 **상수**와 메소드만 멤버로 가질 수 있으며, 생성자를 가질 수 없다. **자바8**부터 인터페이스의 메소드도 **실행블록**을 가질 수 있으며, 디폴트 메소드와 정적 메소드도 선언이 가능하다.

##### 상수 필드(Constant Field)

런타임시 데이터를 저장하는 필드 대신에, 고정 된 값으로 런타임시 데이터를 바꿀 수 없는 상수는 포함 가능하다.

##### 추상 메소드(Abstract Method)

객체가 가진 메소드의 설명으로, 시그니처만 가지며, 실제 실행부는 구현 객체가 가지고 있다.

##### 디폴트 메소드(Default Method)

인터페이스에 선언되지만, 사실은 구현객체가 가지고 있는 인스턴스 메소드이다. 기존 인터페이스를 확장해 기능을 추가하기 위해 **자바8**에서 추가되었다.

##### 정적 메소드(Static Method)

디폴트 메소드와 달리 객체 없이 인터페이스만으로 호출이 가능하다. **자바8**에서 추가되었다.

#### 8.2.2 상수 필드 선언

상수는 반드시 `public static final` 을 붙여준다. 인터페이스에서 선언된 필드는 해당 키워드를 생략해도 자동적으로 컴파일 과정에서 붙게된다. 상수명은 상수 이름규칙을 동일하게 사용하며, 반드시 **선언과 동시에 초기화** 해주어야 한다.

#### 8.2.3 추상 메소드 선언

인터페이스에 선언된 메소드는 모두 `public abstract` 특성을 갖기 때문에 생략하더라도 컴파일 과정에서 해당 키워드가 붙게 된다. 추상클래스의 추상메소드의 선언과 동일하여 호출 방법만 기술하고 있다.

#### 8.2.4 디폴트 메소드 선언

**Java 8**에 추가된 멤버로, 클래스의 인스턴스 메소드와 동일한 형태를 가지며, `default`라는 키워드가 리턴 타입 앞에 붙는다. 자동적으로 `public`이 컴파일 과정에서 붙는다. 추상메소드와 달리 선언시  `;` 이 필요없다.

```java
public default 리턴타입 메소드명(매개변수, ...){...}
```

#### 8.2.5 정적 메소드 선언

**Java 8**에 추가된 멤버로 클래스의 정적메소드와 동일한 형태로, `public`이 컴파일시 리턴 타입 앞에 붙는다.

```java
public static 리턴타입 메소드명(매개변수, ...){...}
```

### 8.3 인터페이스 구현

클라이언트 코드가 인터페이스의 메소드를 호출하면 인터페이스는 객체의 메소드를 호출한다. 이러한 대상이 되는 객체를 구현 객체라고 하고 구현객체를 생성하는 클래스를 구현 클래스라 한다

#### 8.3.1 구현 클래스

아래와 같이 구현클래스를 선언한다

```java
public class 구현클래스명 implements 인터페이스명{
    method1();
    method2();
}
```

클래스 선언 블록안에는 인터페이스의 선언된 추상메소드가 반드시 구현되어야 한다. 인터페이스의 메소드는 기본적으로 `public` 접근제한을 가지기 때문에 더 낮은 접근제한으로 구현할 수 없다. 만약 인터페이스에 선언된 추상메소드를 구현하지 않으면, 구현클래스는 자동적으로 추상클래스가 된다. 따라서 선언부에 `abstract`키워드를 추가해야 한다.

```java
public abstract class 구현클래스명 implements 인터페이스명{
    method1(){
    }
    //method2(); 를 구현하지 않았으므로 abstract 클래스가 된다.
}
```

#### 8.3.2 익명 구현 객체

일회성의 구현 객체를 만들기 위해 소스파일을 만들고 클래스 선언을 하는 것은 비효율 적이기에 **익명 구현 객체**를 사용한다.

```java
인터페이스 변수명 = new 인터페이스(){
    // 추상메소드의 구현 및 익명클래스의 내용
}
```

#### 8.3.3 다중 인터페이스 구현 클래스

> 객체는 다수의 인터페이스 타입으로 사용할 수 있다.

다 수의 인터페이스를 구현한다는 의미는 구현 클래스가 다수의 인터페이스에 정의된 모든 추상 메소드를 구현한다는 의미이다. 만약 하나라도 누락되면 이는 추상클래스로 선언해야 한다.

```java
public class 구현클래스명 implements 인터페이스A, 인터페이스B{
    //인터페이스 A의 추상메소드 구현
    //인터페이스 B의 추상메소드 구현
}
```

이 경우 개발 코드에서 객체에 대한 사용은 인터페이스를 통하기 때문에, 인터페이스A 타입으로 선언된 객체는 인터페이스B 메소드에 접근할 수 없다.

### 8.4 인터페이스 사용

개발 코드에서 인터페이스는 클래스의 필드, 매개변수, 로컬변수로 선언될 수 있으며, 이렇게 선언된 인터페이스에 구현 객체가 대입될 수 있다.

#### 8.4.1 추상 메소드 사용

구현 객체가 인터페이스 타입변수에 대입되면, 해당 타입에 선언된 추상 메소드를 개발 코드에서 호출할 수 있게 되며, 실제로 호출되는 것은 구현객체의 메소드이다.

#### 8.4.2 디폴트 메소드 사용

디폴트 메소드는, 추상메소드가 아닌 **인스턴스 메소드**로 취급 되기 때문에 반드시 구현객체가 필요하다. 즉 모든 구현객체에 디폴트로 선언되어있는 메소드라고 생각하면 된다. 구현클래스에서 오버라이딩을 하여서 수정할 수도 있다. 오버라이딩 유무에 따라서 결과가 달라질 수 있다.

#### 8.4.3 정적 메소드 사용

인터페이스 정적 메소드는 클래스의 정적 메소드 처럼 바로 호출이 가능하다.

### 8.5 타입 변환과 다형성

> 다형성은 하나의 타입에 대입되는 객체에 따라서 실행 결과가 다양한 형태로 나오는 성질을 말한다.

상속에서 살펴본 것과 같이 인터페이스 타입에 어떤 구현객체가 대입되느냐에 따라서 클라이언트 코드에서 해당 타입변수에 대한 호출결과가 달라진다. 결국 인터페이스는 **사용방법이 동일한 클래스**를 작성하는 기술을 통해 다형성을 구현하는 것이다.

인터페이스는 메소드의 매개 변수의 타입으로 많이 사용된다. 이러한 방식으로는 해당 메소드 호출시 매개값으로 다양한 구현객체를 넘겨줄 수 있기 때문이다. (전략 패턴)

#### 8.5.1 자동 타입 변환(Promotion)

구현 객체가 자신의 클래스가 구현한 인터페이스 타입으로 자동 변환되는 것을 자동 타입 변환 이라 한다. 구현객체의 상속받은 자식 클래스도 인터페이스 타입으로 변환 될 수 있음을 기억하자

#### 8.5.2 필드의 다형성

상속에서의 필드 다형성과 동일한 것처럼, 클래스 내부의 필드 타입이 인터페이스로 선언되어 있다면, 해당 인터페이스를 구현하는 어떠한 구현 객체든 대입할 수 있다.

#### 8.5.3 인터페이스 배열로 구현 객체 관리

인터페이스 배열로 선언된 배열변수에 구현객체를 대입하여서도 `for`문을 통해 사용할 수 있다.

#### 8.5.4 매개 변수의 다형성

자동 타입변환은 주로 메소드를 호출할 때 매개변수로 구현객체를 넘겨주는 방식에서 많이 일어난다. 매개변수를 인터페이스 타입으로 선언하고, 해당 자리에 구현객체를 전달해서 메소드 내부에서 동일한 작업을 하지만 결과가 달라지는 다형성을 구현한다.

#### 8.5.5 강제 타입 변환(Casting)

구현 객체가 인터페이스 타입으로 자동변환되면, 해당 인터페이스가 가진 메소드만 사용가능한 제약 사항이 생긴다. 만약 구현객체가 다수의 인터페이스를 구현한 경우에도 클라이언트 코드의 변수의 타입에 따라서 사용가능한 메소드 및 필드가 정해지는 것이다. (구현 객체 내부적으로 호출 되는 경우는 제외)

만약 해당 구현객체의 메소드 중 타 인터페이스나, 모든 필드와 메소드에 접근해야 할 경우에는 강제 타입변환을 해야한다. 

```java
ImplClass implClass = (ImplClass) interVariable; // 구현클래스로 강제변환
AnotherInterface anIf = (AnotherInterface) interVariable; // 다른 인터페이스로 변환
```

위와 같이 강제변환을 하면, 구현클래스 전체 필드와 메소드에 대한 접근, 그리고 해당 구현객체가 구현하는 다른 인터페이스에 대한 접근이 가능하다.

#### 8.5.6 객체 타입 확인(`instanceof`)

강제 타입변환은 변환하고자 하는 구현객체의 실제 클래스를 알아야지 가능하다. 이를 무시하고 변환할 경우 상속의 경우와 같이 `ClassCastException`이 발생할 수도 있다. `instanceof`연산자를 사용하면 구현객체가 실제로 어떠한 구현클래스의 타입인지를 알 수 있다.

```java
타입변수 instanceof 구현클래스 // true 혹은 false의 boolean 타입을 반환한다.
```

### 8.6 인터페이스 상속

인터페이스의 상속은 클래스와 달리 다중 상속을 허용한다. 다음과 같이 `extends` 키워드 뒤에 상속할 인터페이스를 나영하면 된다.

```java
public interface 하위인터페이스 extends 상위인터페이스1, 상위인터페이스2 {...}
```

하위 인터페이스를 구현하는 클래스는 상속된 모든 상위인터페이스의 추상메소드까지 가지고 있어야만 한다. 따라서 아래와 같은 타입 변환도 당연히 가능하다.

```java
하위인터페이스 변수1 = new 구현클래스();
상위인터페이스1 변수2 = new 구현클래스();
상위인터페이스2 변수3 = new 구현클래스();
```

위 클라이언트코드에서 `변수2`는 `하위인터페이스`와`상위인터페이스2`멤버에는 접근할 수 없다는 점을 기억하자.

### 8.7 디폴드 메소드와 인터페이스 확장

인터페이스 내부에 선언과 실행 블록이 모두 작성되어있지만,구현객체가 있어야만 사용할 수 있는, 디폴트 메소드를 자바 8에서부터 허용한 이유를 알아보자

#### 8.7.1 디폴트 메소드의 필요성

라이브러리코드이든 클라리언트코드이든 언제든지 변화는 발생할 수 있으며, 항상 변화에 열려있어야 한다. 만약 인터페이스가 디폴트메소드를 제공하지 않고 추상메소드만 제공할 경우, 인터페이스의 변경은 곧 이를 구현하는 구현클래스의 변경을 의미한다.

**디폴트 메소드**는 구현객체에게 오버라이딩을 통한 **확장성은 분명하게 제공**하지만, 해당 메소드를 구현해야만 하는 **의존성은 부여하지 않는다**. 즉 인터페이스를 기존에 구현하고 있는 클래스들을 그대로 사용하면서 새롭게 개발하는 클래스에서 디폴트 메소드를 사용할 수 있는 것이다.

#### 8.7.2 디폴트 메소드가 있는 인터페이스 상속

인터페이스가 상속되는 경우에, 부모 인터페이스의 디폴트메소드를 활용하는 법은 세 가지이다.

* 디폴트 메소드를 단순히 상속만 받는다
* 재정의를 통해서 실행 내용을 변경한다.
* 디폴트 메소드를 추상 메소드로 재선언한다.

첫 번째와 두 번째 경우는 일반적인 클래스의 상속에서 일어날 수 있는 경우라고 할 때에, 세번째 경우는 하위 인터페이스를 구현하는 클래스에게 디폴트메소드를 추상메소드로 바꿈으로서 구현을 강제하는 효과를 가진다.
