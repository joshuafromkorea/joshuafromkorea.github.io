---
layout: post
title: "이것이 자바다 self study - chapter 3"
date: 2018-11-18
categories:
---
역시 언제공부했는지 모르는 3장을 업로드한다. Chapter 6은 12월 5일에 작성했다고 적어놔서, 대충 비스무레하게 이때 하지않았을까 하는 생각으로 올린다. 11월의 경우엔 분당 개발자 스터디에서도 토비 스프링 진도가 나가기 시작하고, 개발공부에 재미가 붙었던 시기로 기억해서 아마도 주말에 초반 4장은 바로 나갔던 것 같기도 하다.

아무래도 초반에는 아는 부분이라서 그런지 뭔가 간결해서 블로그에 올려도 될 것 같은데, 후반에 가면 모르는 내용투성이라 문과식 공부비법으로 책을 거의 그대로 베끼거나 책을 이해한다음에 동일한 분량의 내용을 나의 말로 풀어쓰는 (paraphrasing) 수준으로 되어있다.

_이것이 자바다_ 1권을 마치고, 내가 self-study 하는 것에 대해서 관심이 있던 동기들과 책을 빌려준 동기한테 markdown 전체를 pdf로 만들어서 공유해줬는데... 한명한테 내용이 너무 길다고 욕먹었다. 아무튼 초반에는 간결하게 잘 썻던 것 같아서..
## Chapter 3 연산자

### 3.1 연산자와 연산식

* Java는 다양한 연산자를 제공한다, 피연산자와 연산자를 통해 산출 되는 값은 연산자별로 다르다.
* 필요한 피연산자수에 따라 단항, 이항, 삼항 연산자로 구분된다.
* 연산자와 피연산자로 이뤄진 연산식은 반드시 하나의 값을 산출한다.
* 연산식은 다른 연산식의 피연산자가 될 수 있다.

### 3.2 연산의 방향과 우선순위

* 연산자의 우선순위 정리
  * 단항, 이항, 삼항 연산자 순으로 우선순위를 가진다
  * 산술, 비교, 논리, 대입 연산자 순으로 우선순위를 가진다.
  * 단항과 대입을 제외한 모든 연산방향은 좌에서 우이다.
  * 복잡한 연산식에는 괄호를 사용하는 것이 좋다.

위내용을 한눈에 보는 표는 아래와 같다.

| 연산자                                                       | 연산 방향 | 우선순위 |
| ------------------------------------------------------------ | :-------: | :------: |
| 증감(`++`,`--`), 부호(`+`,`-`) 비트(`~`), 논리(`!`)  → **(단항연산자)** |    ◀◀◀    | **높음** |
| 산술 (`*`,`/` ,`%`)                                          |    ▶▶▶    |    ▲     |
| 산술(`+`,`-`)                                                |    ▶▶▶    |    ▲     |
| 쉬프트(`<<`,`>>`,`>>>`)                                      |    ▶▶▶    |    ▲     |
| 비교(`<`,`>`,`<=`,`>=`,`instanceof`)                         |    ▶▶▶    |    ▲     |
| 비교(`==`, `!=`)                                             |    ▶▶▶    |    ▲     |
| 논리(`&`)                                                    |    ▶▶▶    |    ▲     |
| 논리(`^`)                                                    |    ▶▶▶    |    ▲     |
| 논리(`|`)                                                    |    ▶▶▶    |    ▲     |
| 논리(`&&`)                                                   |    ▶▶▶    |    ▲     |
| 논리(`||`)                                                   |    ▶▶▶    |    ▲     |
| 조건(`?:`)                                                   |    ▶▶▶    |    ▲     |
| 대입(`=`,`+=`,`-=`,`*=`,`/=`,`%=`,`&=`,`^=`,`|=`,`<<=`,`>>=`,`>>>=`) |    ◀◀◀    | **낮음** |

### 3.3 단항 연산자

##### 3.3.1 부호 연산자(`+`,`-`)

* `+` 의 경우엔  피연산자의 부호 유지, `-`의 경우엔 **피연산자의 부호변경**
* 부호 연산자의 산출타입은 **`int`타입**이다.

#### 3.3.2 증감 연산자(`++`,`--`)

* 연산자의 위치에 따라, **선행**할 경우 다른연산을 **수행전에 증감연산 수행**, **후행**할 경우 다른연산 **수행 후 증감연산 수행**
* `i++`와 `i=i+1`은 본질적으로 바이트코드가 동일하다.

#### 3.3.3 논리 부정 연산자(`!`)

* `boolean` 타입만 피연산자로 받아, `true`▶`false` 혹은 `false`▶`true`의 연산을 수행한다.

#### 3.3.4 비트 반전 연산자(`~`)

* **정수타입** 피연산자에만 사용되며, 피연산자의 2진수 표기에서 비트를 반전시킨다.
* 연산식 수행전에 피연산자가 **`int` 타입**으로 변환된다.
* 이를 통해서 부호가 반대인 정수를 구할 수 있다.

```java
byte v1 = 10;
int v2 = ~v1+1;  // -10

byte v3 = -10;
int v4 = ~v3+1;  // 10
```

* Java는 정수값을 32비트의 이진문자열로 반환하는 `Integer.toBinaryString(int i)` 를 제공한다.

### 3.4 이항 연산자

#### 3.4.1 산술 연산자(`+`,`-`,`*`,`/`,`%`)

##### 피연산자 타입이 다를 때의 산술식 수행 규칙

1. 피연산자가 모두 정수, `int` 타입(4byte)보다 작은 타입일경우 모두 **`int`로 변환**, 산출타입은 `int`
2. 피연산자가 모두 정수, `long` 타입이 있을 경우 모두 **`long`으로 변환**, 산출타입은 `long`
3. 피연산자에 실수타입(`float`, `double`)이 있을 경우, **큰 실수 타입으로 변환**, 산출타입은 실수

##### 오버플로우 탐지

산술식의 산출값이 산출타입으로 표현가능하지 않으면 **오버플로우 발생** 및 쓰레기값을 얻을 수 있다. 

##### 정확한 계산은 정수 사용

실수 타입은 부동소수점을 사용하기 때문에, 정확한 실수 값이 필요한 경우 정수로 연산 후 실수로 변환한다.

##### NaN과 Infinity 연산

* `/` 또는 `%` 연산자를 사용할때, 좌측 연산자가 정수 타입이면, 우측 피연산자는 0을 사용할 수 없다.
* 실수 타입인 `0.0` 혹은 `0.0f` 로 해당 연산을 하면, Infinity 혹은 NaN이 산출된다.
  * Infinity 와 NaN은 피연산자로 사용될 경우 항상 해당값을 산출하므로 다음연산을 진행해서는 안된다.

##### 입력값의 NaN 검사

실수 값을 입력받는 경우, `Double.isNaN()`을 사용해서 해당 실수에 대한 검사를 수행해야, 제대로된 산출 결과를 얻을 수 있다.

#### 3.4.2 문자열 연결 연산자 (`+`)

문자열과 숫자가 혼합된 `+` 연산식은 왼쪽에서 오른쪽으로 연산이 진행된다.

```Java
System.out.println("JDK"+3+3.0); //JDK33.0
System.out.println(3+3.0+"JDK"); //6.0JDK
```

#### 3.4.3 비교 연산자 (`<`,`<=`,`>`,`>=`,`==`,`!=`)

* 비교 연산자를 사용한 연산식의 산출 값은 `boolean` 타입이다.
* 피연산자가 `char`타입이면 유니코드 값으로 비교 연산을 수행한다.
* 피연산자 타입이 다를 경우 타입변환을 수행한다.
* 실수의 경우 부동소수점의 특징으로 인해 정확한 값 표현이 안되 비교연산이 제대로 안될 수 있다.

```java
System.out.println('A'==65); //true
System.out.println(3==3.0); //true
System.out.println(0.3==0.3f); //부동소수점으로 인해 false
System.out.println((float)0.3==0.3f); //float으로 타입 일치시켜서 true
System.out.println((int)0.3==(int)0.3f); //정수형으로 바꾸고 연산해서 true
```

* 스트링에서는 오직 `==` 연산자와 `!=`연산자만 사용할 수 있으나, 이는 값이 아닌 주소값의 비교이기 때문에 별도의 `String.equals()`메서드를 사용하여 수행한다.

#### 3.4.4 논리 연산자(`&&`,`||`,`|`,`&`,`|`,`^`,`!`)

* 논리 연산자의 피연산자와 산출타입은 모두 `boolean`이다
* 논리곱 (AND) 연산: 모두 `true`이면 `true` 반환, 이외에는 `false`
  * `&&`의 경우 앞의 피연산자가 `false`라면 추가연산을 수행하지 않아 `&`보다 효과적
* 논리합 (OR) 연산: 모두 `false`이면 `false`반환, 이외에는 `true`
  * `||`의 경우 앞의 피연산자가 `true`라면 추가 연산을 수행하지 않아 `|`보다 효과적
* 배타적논리합 (XOR) 연산: 피연산자가 서로 다를 경우 `true`반환, 같으면 `false`
* 논리부정 (NOT) 연산: 피연산자 논리값을 toggle

#### 3.4.5 비트 연산자(`&`,`|`,`^`,`~`,`<<`,`>>`,`>>>`)

* 데이터를 bit단위로 연산한다, 즉 0과 1이 피연산자가 되며 **정수 타입**만 비트 연산 가능하다.

##### 비트 논리 연산자 (`&`, `|`,`^`)

피연산자의 2진수의 비트끼리 AND, OR, XOR 연산을 수행한다.

##### 비트 이동 연산자(`<<`, `>>` ,`>>>`)

비트이동(shift) 연산은 정수(a) 데이터의 비트를 좌측 또는 우측으로 (b만큼) 밀어서 연산한다. 

* **`a << b`**: 정수 a의 각 비트를 b만큼 왼쪽으로 이동, 빈자리는 0으로 채워진다
* **`a >> b`**: 정수 a의 각 비트를 b만큼 오른쪽으로 이동, 빈자리는 MSB로 채워진다.
* **`a >>> b`**: 정수 a의 각 비트를 b만큼 오른쪽으로 이동, 빈자리는 0으로 채워진다.

#### 3.4.6 대입 연산자(`=`, `+=`, `-=`, `*=`, `/=` `%=`, `&=`, `^=`, `|=`, `<<=`, `>>=`, `>>>=`)

* 대입 연산자는 모든 연산자들 중에서 **가장 낮은 연산 순위**를 가지고 있기에 제일 마지막에 수행된다.
* 수행 방향이 우에서 좌이기 때문에, 복합 대입연산자 사용시 우측 피연산자로 변수를 나눠서 다시 대입한다.

### 3.5 삼항 연산자

삼항 연산자는 3개의 피연산자가 존재하는데 첫번째 피연산자로 `boolean`타입 산술식을 `?` 연산자 앞에 받으며, `true`일 경우 `:` 앞의 피연산자가 산출되고, `false`의 경우는 뒤의 피연산자가 산출된다.

```java
System.out.println(true?"false":"true"); //false 출력
```
