---
layout: post
title: "이것이 자바다 self study - chapter 6"
date: 2018-12-05
categories:
---
이상하게 공부했던 날짜가 적혀져있는 6장이다. 아무래도 클래스라는 개념이 자바에서 매우 중요하다보니 맘을 다잡고 공부했나보다. 하루만에 6장을 끝내고, 바로 다음장을 다음날 완료한 것으로 보이는데, 아마 내가 12월 SM 개발 과제가 매우 쉬운 것이라서 3일정도에 개발 끝내고 회사에서 대놓고 책펴고 자바공부했었던 것으로 기억한다. 

아마도 이번장은 나중에라도 찾아보는 용도의 self-study에 가장 적합한 챕터 중 하나가 아닐까 싶다. _이것이 자바다_를 스스로 공부하는 것과 매주 있는 분당 개발자 스터디에서 공부하던 토비의 스프링을 병행하면서 엄청 재미있었었다. 특히 객체지향에 대해서 더 깊게 이해하게 되고, 당시에 뭔가 면접 질문들 나오면 잘 대답할 수 있을 만큼 개념을 달달 외우게 되었었는데, 실제 면접에서는 잘 대답 못했다....  

## Chapter 6 클래스

### 6.1 객체 지향 프로그래밍

#### 6.1.1 객체란?

물리적 존재 혹은 추상적 대상중에 자신의 속성이 있고 다른 객체와 식별가능 한 것으로, 속성과 동작을가지고 있다. 현실 세계의 객체르 소프트웨어 객체로 설계하는 것을 객체 모델링이라고 한다.

#### 6.1.2 객체의 상호작용

객체는 서로 독립적으로 존재하고, 객체의 상호작용은 해당 객체의 동작을 정의한 메서드를 호출 하는 것으로 한다. 메서드 호출에는 메서드의 이름과, 매개값이 필요하다. 또한 메서드는 리턴 값을 가지는데 이는 호출한 객체에게 돌려주는 값이다.

#### 6.1.3 객체 간의 관계

* 집합관계: 별개의 객체가 다른 객체의 속성이 되는 관계
* 사용관계: 한 객체가 다른 객체의 메서드를 호출하는 경우 사용관계
* 상속관계: 상위 객체를 기반으로 하위 객체를 생성하는 관계

#### 6.1.4 객체 지향 프로그래밍의 특징

##### 캡슐화(Encapsulation)

객체의 속성과 메서드중에 외부에 공개된 것과 공개되지 않는 것으로 구분되 노출을 조절하는 것을 캡슐화라고 한다. 캡슐화를 위해서는 접근제한자 (Access Modifier)를 사용한다.

##### 상속(Inheritance)

상위객체가 하위객체에게 자신의 필드(속성)과 메서드를 사용할 수 있도록 하는 것을 말한다. 이를 통해 하위 객체를 효율적으로 생산하며, 잘 개발된 객체의 재상용성 및 확장의 용이성을 가지게 해준다.

##### 다형성(Polymorphism)

하나의 타입을 구현 혹은 상속한 하위 객체가 상위 객체 혹은 인터페이스의 타입으로 사용될 수 있는 것을 말한다. 이를 통해 객체간의 의존성을 약하게 만들 수 있다

### 6.2 객체와 클래스

자바에서 객체의 설계도는 바로 `Class`이다. 이 설계도를 바탕으로 객체를 만드는 것을 인스턴스화 한다고 하며 이렇게 만들어진 객체는 인스턴스라고 한다.

### 6.3 클래스 선언

클래스 선언 식별자 규칙

1. 하나 이상의 문자로 이뤄져야 한다. 
2. 첫 번째 글자는 숫자가 올 수 없다.
3. `$`,`_`외의 특수문자는 사용할 수 없다.
4. 자바가 사용하는 키워드는 사용 불가하다.

### 6.4 객체 생성과 클래스 변수

클래스로부터 객체를 생성할 때는  `new`연산자를 생성한다.  생성된 객체는 힙 영역에 존재하며, 스택영역에 있는 클래스 이름으로 선언한 클래스 변수로 접근 가능하다.

### 6.5 클래스의 구성 멤버

#### 6.5.1 필드

메서드 내에서만 사용되는 변수와 달리, 클래스 내부에 선언되어 생성자와 메서드 전체에 사용되며 객체의 생성과 소멸을 함께하는 변수를 **필드**라고 부른다.

#### 6.5.2 생성자

`new`연산자로 호출되는 중괄호 블록으로, 객체 생성시 초기화를 담당한다. 클래스이 이름과 동일한 이름을 가지며 리턴타입이 없다.

#### 6.5.3 메소드

객체의 동작에 해당하는 중괄호 블록으로 블록 앞에, 메서드 이름, 리턴타입, 매개값을 가지고 있다.

### 6.6 필드

필드로 선언되어야 하는 부분은 객체의 고유데이터, 객체의 현재 상태 데이터, 객체가 가져야할 다른 객체가 되어야 한다.

#### 6.6.1 필드 선언

필드 선언은 **클래스 중괄호** 안쪽이면서 메서드 및 생성자 **바깥쪽**에 존재 하는 것. 초기값을 지정하지 않으면 필드는 타입별로 기본 초기 값을 갖는다.

* boolean 의 초기값은 false, 참조타입의 초기 값은 null;

#### 6.6.2 필드의 사용

클래스 외부에서 접근시에는 도트 (`.`)연산자 사용한다. 값을 대입할 때는 대입 연산자(`=`) 를 사용한다.

### 6.7 생성자

생성자는 기본적으로 `new`연산자를 사용할때 호출된다. 이를 통해 객체 필드를 초기화 하거나 메서드를 호출해서 객체를 사용할 준비를 시킬 수 있다. 생성자가 성공적으로 호출되면 heap에 객체가 생성되고, 리턴 값으로 객체의 주소가 리턴된다.

#### 6.7.1 기본 생성자

모든 클래스에는 반드시 하나의 생성자가 존재한다 = 즉 생성자를 명시하지 않으면 Default 생성자가 byte코드로 추가된다.

* `public` 클래스의 기본 생성자는 `public`으로 생성되지만, 키워드가 없는 클래스는 붙지 않는다.

#### 6.7.2 생성자 선언

생성자는 메서드와 비슷한 모양을 가지나, 리턴타입이 없고 반드시 클래스이름과 동일하다. 매개변수는 받을 수도 있다. 명시적 생성자가 존재할 경우 default 생성자로는 객체생성이 불가능하다.

#### 6.7.3 필드 초기화

객체 생성시 이미 필드는 초기값으로 초기화 된다. 다른 값으로 초기화를 할 때에는 두가지 방법이 있다.

* 초기 값으로 특정 리터럴이나 참조값을 주는 것이고
* 생성자를 통해서 초기 값을 주는 방법이다. 생성자의 매개변수를 통해서 초기화한다.

#### 6.7.4 생성자 오버로딩(Overloading)

매개변수를 달리하는 생성자를 여러 개 선언하는 것

#### 6.7.5 다른 생성자 호출(`this()`)

생성자 오버로딩을 활용할 경우 코드간의 중복이 발생할 수 있다. 매개변수의 수만 달리하고 초기화 내용이 비슷한 경우에는, 다른 생성자를 호출하는 방법을 코드 중복을 피할 수 있다.

* `this()`의 사용은 생성자의 첫번째 줄에만 제한된다.
* 다른 생성자 호출 후에, 중복되지 않는 부분은 초기화를 한다.

### 6.8 메소드

#### 6.8.1 메소드 선언

메소드 선언부를 **signature** 라고 한다. **리턴타입, 메소드이름, 매개변수선언**와 뒤따른 블록으로 구성된다.

* **리턴타입** : 메소드 실행 후 리턴되는 값의 타입을 말한다. 
* **메소드 이름** : 자바 식별자 규칙에 맞게 작성해야한다.
  * 숫자로 시작 금지, `$`와`_`를 제외한 특수 문자 사용 금지
  * 관례적으로 소문자로 시작함
  * camel 표기법 준수
* **매개변수 선언** : 필요한 데이터를 호출하는 client에서 제공받기 위해서, 소괄호 안에 선언
  * **매개변수를 모를 경우** : 배열 타입으로 선언하거나 `(...)` 을 사용해서 배열로 활용

#### 6.8.2 리턴(`return`)문

##### 리턴값이 있는 메소드

리턴 타입이 있는 메소드는 반드시 리턴문을 포함해서 리턴 값을 지정해야 한다. 자동 형변환이 되는 타입이면 리턴문에 사용가능하다.

##### 리턴값이 없는 메소드(`void`)

`void`메소드에서 리턴문을 사용할 수 있다. 메소드를 강제 종료시키는 용도로 사용할 수 있다.

#### 6.8.3 메소드 호출

* 객체 내부에서 호출: 메서드 이름과 매개변수로 호출한다

* 객체 외부에서 호출
  * `static`메소드가 아닌경우엔 객체생성이 반드시 이뤄져야 하며, 도트(`.`)연산자를 사용하여 호출한다.

#### 6.8.4 메소드 오버로딩

만약 **매개변수 타입, 갯수, 순서**가 다르다면, 같은 이름의 메소드를 여러개 선언할 수 있다

### 6.9 인스턴스 멤버와 this

* 사용을 위해서 객체 생성이 필요한 대부분의 필드와 메소드를 인스턴스 멤버라고 부른다.
* 객체와 인스턴스 필드의 경우엔 heap영역에 객체별로 존재하고, **메소드는 메소드영역**에 공유된다.
* 객체 내부에서 인스턴스 멤버에 접근할때는 `this`를 사용한다.

### 6.10 정적 멤버와 `static`

생성된 객체가 아니라 정의된 클래스에 소속된 멤버로 정적 멤버라고 부른다.

#### 6.10.1 정적 멤버 선언

`static`키워드만 사용하면 자동으로 해당 멤버는 정적 필드와 정적 메서드가 된다.

#### 6.10.2 정적 멤버 사용

정적 멤버는 클래스 이름과 함께 도트(`.`)연산자로 접근한다.

#### 6.10.3  정적 초기화 블록

* 정적 필드는 필드 선언과 동시에 초기값이 주는 것이 보통이다.
* 정적 필드에 대한 초기화 작업은 생성자에서 할 수 없다, **객체를 생성하지 않고 쓴다**
* `static { }` 블록안에서 수행하도록 하면된다.
  * 클래스가 메모리에 로딩될 때 자동적으로 실행된다.

#### 6.10.4 정적 메소드와 블록 선언시 주의할점

* 정적 블록안에서는 인트선스 필드나 인스턴스 메서드를 사용할 수 없다. (컴파일에러 발생)
* 만약 인스턴스 멤버를 사용하고 싶다면 블록내에서 객체를 생성 후 접근한다

#### 6.10.5 싱글톤(Singleton)

* 프로그램 전체에서 단 하나의 객체만 만들도록 보장 하는 것
* 일반적으로 `private` 접근제한자를 통해 생성자 호출을 막고, `getInstance()`메소드를 구현하여 `private static`으로 생성한 객체를 반환하는 식으로 구현한다.

### 6.11 `final`필드와 상수

#### 6.11.1 `final` 필드

필드를 `final` 키워드를 사용하여 선언하면, 초기값 이후에 수정될 수 없다는 의미이다. 선언시에 초기값을 주거나 생성자를 통해 주는 것밖에 값을 주는 방법이 없다. **초기화 되지 않은** final 필드가 존재하면 컴파일 에러가 발생한다.

#### 6.11.2 상수(static final)

* 공용(`static`)으로 쓸수 있는 고정(`final`)값을 자바에서는 상수로 취급한다.
* 상수 이름은 모두 대문자로 하고 혼합 단어는 언더바(`_`)로 구분한다.

### 6.12 패키지

* 패키지는 클래스를 체계적으로 관리하기 위한 파일시스템 폴더의 역할을 한다
* 패키지는 또한 클래스를 유일하게 만드는 **식별자**의역할도 한다.

#### 6.12.1 패키지 선언

* 클래스내부에 패키지가 선언되어있으면, 컴파일러가 자동으로 파일시스템의 폴더로 생성한다
* 패키지명 생성 규칙
  * 숫자로 시작 금지, `_`,`$`제외한 특수문자 사용금지
  * java로 시작하는 패키지 사용금지(java 표준 API용)
  * 모두 소문자로 작성하는 것이 관례

일반적으로 개발 회사의 도메인 이름을 역순으로 패키지 이름을 짓는 것이 관례이다.

#### 6.12.2 패키지 선언이 포함된 클래스 컴파일

패키지 선언된 포함된 클래스 컴파일할때는 `javac` 명령어와 함께 `-d 경로` 옵션을 주어 패키지 폴더가 생성될 곳을 지정해야 한다.

#### 6.12.3 이클립스에서 패키지 생성과 클래스 생성

IDE의 패키지 생성 기능을 사용하면 패키지를 먼저생성하고, 클래스 추가가 가능하다

#### 6.12.4 `import`문

* 다른 패키지의 클래스를 사용하기 위해서 `import`문을 사용해서 선언하고, 클래스를 사용할 때에는 패키지이름을 생략한다.

* `...*`를 사용하면 해당 경로의 하위 클래스를 모두 가지고오지만, 하위 패키지를 가지고 오지는 않는다.

### 6.13 접근 제한자

* 라이브러리 클래스를 설계 할때에는 외부 클래스에서 접근할 수 있는 멤버와 없는 멤버로 구분해서 설계한다
* 이를 구현하기 위해서 접근제한자, `public`, `protected`,`(default)`,`private` 을 쓴다

| 접근 제한자 | 적용 대상                    | 접근할 수 없는 클래스                          |
| ----------- | ---------------------------- | ---------------------------------------------- |
| `public`    | 클래스, 필드, 생성자, 메소드 | 없음(모두접근가능)                             |
| `protected` | 필드, 생성자, 메소드         | 자식 클래스가 아닌 다른 패키지에 소속된 클래스 |
| `(default)` | 클래스, 필드, 생성자, 메소드 | 다른 패키지에 소속된 클래스                    |
| `private`   | 필드, 생성자, 메소드         | 모든 외부 클래스                               |

#### 6.13.1 클래스의 접근 제한

클래스에 적용 할 수 있는 접근제한은 `public`과 `(default)` 두 가지 이므로 어디서 사용할 것인지 고려해서 결정해야 한다.

##### `default` 접근제한

다른 패키지에서는 사용할 수 없다

##### public 접근제한

다른 사용자 및 다른 패키지에서 사용할 수 있다.

#### 6.13.2 생성자의 접근 제한

| 접근제한자  | 설명                                                         |
| ----------- | ------------------------------------------------------------ |
| `public`    | 모든 패키지에서 아무런 제한 없이 생성자를 호출 할 수 있다. <br />생성자가 `public` →클래스도 `public`<br />클래스가 `default` 일 경우, 같은 패키지안에서만 생성자 호출 가능 |
| `protected` | 같은 패키지에 속하는 클래스에서 생성자 호출 가능<br />다른패키지에 속한 클래스도 상속받은 클래스라면 호출 가능 |
| `(default)` | 접근제한자 생략시 `default`, 같은 패키지에서 제한없이 생성자 호출 가능 |
| `private`   | 어떤 외부 클래스에서도 생성자 호출 불가, 오로지 내부에서만 호출 가능 |

#### 6.13.3 필드와 메소드의 접근 제한

| 접근제한자  | 설명                                                         |
| ----------- | ------------------------------------------------------------ |
| `public`    | 모든 패키지에서 아무런 제한 없이 필드와 메소드를 사용 할 수 있다. <br />필드와 메소드가`public` →클래스도 `public`<br />클래스가 `default` 일 경우, 같은 패키지안에서만 생성자 호출 가능 |
| `protected` | 같은 패키지에 속하는 클래스에서 필드와 메소드 사용 가능<br />다른패키지에 속한 클래스도 상속받은 클래스라면 사용 가능 |
| `(default)` | 같은 패키지에서만 사용가능, 다른 패키지에서는 사용 불가      |
| `private`   | 오로지 클래스 내부에서만 사용 가능                           |

### 6.14 Getter와 Setter 메소드

**객체 지향 프로그래밍**에서는 객체의 데이터는 객체 외부에서 **직접 접근하지 못한다**. 객체의 무결성을 깨지지 않게 하기 위해서, 객체의 데이터에 대한 접근과 수정을 제공하는 것이 Getter와 Setter 메소드 이다.

### 6.15 어노테이션

> **어노테이션(Annotation)**은 **메타데이터(metadata)**라고 볼 수 있다. 메타데이터란 어플리케이션이 처리하는 데이터가 아니라, 컴파일 과정과 실행 과정에서 코드를 어떻게 컴파일하고 처리할지를 알려주는 정보이다.

**어노테이션의 용도**

* 컴파일러에게 코드 문법 에러를 체크하도록 정보를 제공
* 소프트웨어 개발 툴이 빌드나 배치 시 코드를 자동으로 생성할 수 있도록 정보를 제공
* 실행 시(런타임 시) 특정 기능을 실행하도록 정보를 제공

#### 6.15.1 어노테이션 타입 정의와 적용

어노테이션을 정의할 때는 `@interface`문을 사용하여 아래와 같이 정의한다.

```java
public @interface AnnotationName{
}
```

이렇게 정의한 어노테이션은 코드에서 사용할 수 있다.

```java
@AnnotationName
```

어노테이션은 엘리먼트를 멤버로 가질 수 있다. 엘리먼트의 타입은 기본 데이터 타입이나, String, Enum 클래스등이 올 수 있으며, 이런 타입의 배열 타입도 가능하다. 타입 뒤에는 메소드를 작성하는 것처럼 소괄호`()`가 필요하다. 엘리먼트 뒤에는 `default`문을 통해 기본 값을 지정할 수 있다.

```java
public @interface AnnotationName{
    String stringElement();
    int intElement() default 5;
}
```

`stringElement`의 경우 기본값이 없기 때문에 사용시 반드시 기술해야 하며, `intElement`는 생략시 기본 값이 적용된다.

```java
@AnnotationName(stringElement="string", intElement=5);
//또는
@AnnotationName(stringElement="string");
```

`value()`라는 이름으로 선언된 엘리먼트는 해당 어노테이션의 기본 값이 되어서 사용시에 엘리먼트 이름없이 사용할 수 있다.

```java
@AnnotationName("값"); // "값"이라는 스트링 리터럴이 value라는 엘리먼트에 전달됨
```

#### 6.15.2 어노테이션 적용 대상

어노테이션을 적용할 수 있는 대상은 `java.lang.annotation.ElementType`에 열거상수로 정의되어 있다.

```java
package java.lang.annotation;
public enum ElementType {
    /** Class, interface (including annotation type), or enum declaration */
    TYPE,
    /** Field declaration (includes enum constants) */
    FIELD,
    /** Method declaration */
    METHOD,
    /** Parameter declaration */
    PARAMETER,
    /** Constructor declaration */
    CONSTRUCTOR,
    /** Local variable declaration */
    LOCAL_VARIABLE,
    /** Annotation type declaration */
    ANNOTATION_TYPE,
    /** Package declaration */
    PACKAGE
}
```

`@Target`어노테이션을 사용하여 어노테이션이 적용될 대상을 아래처럼 지정할 수 있다. `@Target`어노테이션의 경우엔 기본 엘리먼트인 `value()`가 `ElementType`배열을 값으로 가진다.

```java
@Target({ElementType.TYPE, ElementType.FIELD, ElementType.METHOD})
public @interface AnnotationName{
}
```

위와 같이 타겟이 설정된 어노테이션의 경우, `Class`,`Interface`,`Enum`,필드, 메소드에만 어노테이션을 적용할 수 있다.

#### 6.15.3 어노테이션 유지 정책

어노테이션 정의시, **사용 용도**에 따라 해당 어노테이션을 **어느 범위**까지 유지할 것인지 지정해야 한다. 이런 범위는 `java.annotation.RetentionPolicy`에 열거상수로 정의되어있다.

```java
package java.lang.annotation;
public enum RetentionPolicy {
    /**
     * Annotations are to be discarded by the compiler.
     */
    SOURCE,

    /**
     * Annotations are to be recorded in the class file by the compiler
     * but need not be retained by the VM at run time.  This is the default
     * behavior.
     */
    CLASS,

    /**
     * Annotations are to be recorded in the class file by the compiler and
     * retained by the VM at run time, so they may be read reflectively.
     *
     * @see java.lang.reflect.AnnotatedElement
     */
    RUNTIME
}
```

* `SOURCE` : 소스상에서만 어노테이션 정보를 유지하며, 소스 분석시에만 의미가 있고 바이트코드엔 남지않음
* `CLASS`: 바이트 코드까지 어노테이션 정보 유지, 하지만 리플렉션을 이용해서 어노테이션 정보 획득불가
* `RUNTIME`: 바이트 코드파일과 리플렉션을 이용해 런타임시 어노테이션 정보 접근 가능

여기서 리플렉션(Reflection)이란 런타임시에 클래스의 메타 정보를 얻는 기능을 말한다. 어노테이션 유지정책에 대해서는 @Retention` 어노테이션을 사용해서 지정해줄 수 있고, 위의 세가지 상수 중 하나를 엘리먼트로 넘겨주면 된다. 아래는 런타임 접근범위를 가진 어노테이션의 선언이다.

```java
@Target({ElementType.TYPE, ElementType.FIELD, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface AnnotationName{
}
```

#### 6.15.4 런타임 시 어노테이션 정보 사용하기

런타임시 어노테이션 적용을 확인하고 특정 작업을 수행하는 방법에 대해서 알아보자. 클래스에 대한 어노테이션 정보는 `java.lang.Class`를 이용하면 되지만, 그이외에 클래스 내부에 대한 정보는 `Class`의 메소드를 통해서 `java.lang.reflect`패키지의 배열을 얻어야 한다.

| 리턴 타입       | 메소드명(매개변수)     | 설명               |
| --------------- | ---------------------- | ------------------ |
| `Field[]`       | `getFields()`          | 필드 정보를  리턴  |
| `Constructor[]` | `getConstructors()`    | 생성자 정보를 리턴 |
| `Method[]`      | `getDeclaredMethods()` | 메소드 정보를 리턴 |

이후에 리턴된 타입이 가지고 있는 메소드를 통해서 적용된 어노테이션 정보를 얻을 수 있다.

| 리턴 타입      | 메소드명(매개변수)                                    | 설명                                                         |
| -------------- | ----------------------------------------------------- | ------------------------------------------------------------ |
| `boolean`      | `isAnnotationPresent(Class<? extends Annotation> ac)` | 어노테이션 적용 여부 검사, 대상이 `Class`일 경우 상위클래스도 검사하여 `true`반환 |
| `Annotation`   | `getAnnotation(Class<T> ac )`                         | 지정한 어노테이션이 적용되어 있으면 리턴하고 그렇지 않으면 `null` 상위 클래스도 검사 |
| `Annotation[]` | `getAnnotation()`                                     | 모든 어노테이션을 리턴한다. 상위클래스도 검사 없을시 길이가 0인 배열 리턴 |
| `Annotation[]` | `getDeclaredAnnotations()`                            | 직접 적용된 모든 어노테이션을 리턴, **상위클래스 어노테이션은 포함되지 않는다.** |

