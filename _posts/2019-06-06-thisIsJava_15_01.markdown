---
layout: post
title: "이것이 자바다 self study - chapter 15 - 2권 임시 종료"
date: 2019-06-06
categories:
---

14장은 람다를 다루고 있고, 16장은 스트림을 다루고 있다. 원래 이것이 자바다를 공부하기전에 자바8의 책을 보려고 했었는데, 그 책을 보면서 다룰 내용이라 스킵하고 본장의 컬렉션 프레임워크를 마지막으로 당분간 이것이 자바다는 다루지 않도록 한다. 물론 네트워크 부분이 남아있긴 한데.. 일단 자바8을 빨리 해보고 싶다.

---

## Chapter 15 컬렉션 프레임워크

### 15.1 컬렉션 프레임워크 소개

> 자바는 배열의 문제점을 해결하고, 널리 알려져 있는 자료구조를 바탕으로 객체들을 효율적으로 추가, 삭제, 검색 할 수 있도록 `java.util` 패키지에 컬렉션과 관련된 인터페이스와 클래스들을 포함시켜 놓았다. 이들을 총칭해서 컬렉션 프레임워크라고 부른다.

##### 자바 컬렉션 프레임워크의 구조

<div class="mermaid">
graph TB
C[Collection]
L[List]
S[Set]
AL(ArrayList)
V(Vector)
LL(LinkedList)
HS(HashSet)
TS(TreeSet)
C---L
C---S
L-.-AL
L-.-V
L-.-LL
S-.-HS
S-.-TS
M[Map]
HM(HashMap)
HB(Hashtable)
TM(TreeMap)
P(Properties)
M-.-HM
M-.-HB
M-.-TM
M-.-P
</div>

### 15.2 `List` 컬렉션

- 자료를 일렬로 늘여놓은 구조의 컬렉션으로, 자료가 들어가는 위치의 값을 나타내는 인덱스가 있다.

#### 15.2.1 `ArrayList`

- 배열과 유사한 개념을 가진 `List` 구현 클래스로 크기의 변경이 가능하다는 차이점을 가진다
- 특정한 위치에 객체를 입력하거나 제거하는 일이 빈번한다면, `LinkedList`를 사용하는 것이 낫다
  - 단 가장 마지막에 객체를 추가하거나, 인덱스 검색을 하는 경우엔 `ArrayList`가 유리하다

#### 15.2.2 `Vector`

- `ArrayList`와 동일한 형태를 가지고 있지만, 메소드가 모두 `synchronized`되어있기 때문에 멀티 스레드가 동시에 실행할 수 없다는 것이다. 즉 Thread Safe한 `ArrayList`이다

#### 15.2.3 `LinkedList`

- 입력된 객체간의 인접 링크로 연결하여 체인처럼 관리 하기 떄문에, 빈번한 객체 삽입 삭제시에 유리하다

### 15.3 Set 컬렉션

- `List`가 순서가 보장되는데에 반해서, `Set` 순서없는 컬렉션이다. 또한 `Set`은 중복값을 허용하지 않는다.

- `Set` 컬렉션은 인덱스 참조가 되지 않는데신에, 전체 객체를 반복해서 가져오는 `Interator`를 반환한다.

  - 다음은 `Iterator` 인터페이스에 선언된 메소드들이다.

    | 리턴 타입 | 메소드명    | 설명                                               |
    | --------- | ----------- | -------------------------------------------------- |
    | `boolean` | `hasNext()` | 가져올 객체가 있으면 true, 없으면 false를 리턴한다 |
    | `E`       | `next()`    | 컬렉션에서 하나의 객체를 가져온다                  |
    | `void`    | `remove()`  | `Set` 컬렉션에서 객체를 제거한다                   |

  - 주의할 점은 `Iterator`에 선언된 `remove()`는 반복자에서 제거하는 것이 아니라, 반복자를 만든 `Set` 컬렉션에서 값을 제거한다.

  ```java
  while(iterator.hasNext()){
      if(iterator.next().equals("홍길동")){
          iterator.remove(); //홍길동은 set에서 삭제된다.
      }
  }
  ```

#### 15.3.1 `HashSet`

- `HashSet`은 중복저장을 방지하기 위해서 동일객체임을 판단할때 객체의 `hashCode()`와 `equals()` 메소드를 통해서 판단한다

<div class="mermaid">
graph LR
	1["hashcode() 리턴값"]
	2["equals() 리턴값"]
	1-->|같음|2
	D((다른객체))
	1-->|다름|D
	D-->|저장|Set
	2-->|false|D
	S((동등객체))
	S-->저장안함
	2-->|true|S
</div>

- 따라서, 개발자가 생성한 클래스의 객체들이 의도한대로 `HashSet`에 저장되기 위해서는, `String` 클래스처럼 `hashCode()` 와 `equals()` 메소드를 재정의 해야한다.

### 15.4 `Map` 컬렉션

- 흔히 말하는 Key & Value 쌍으로 이루어진 Entry 객체를 저장하는 구조를 가진 것이 `Map` 컬렉션이다.
- Value는 중복될 수 있지만 키는 중복될 수 없기 때문에, 동일 키가 입력되면 Value는 대체된다.

#### 15.4.1 `HashMap`

- `HashMap`은 `HashSet`과 동일한 방법으로 Key값의 중복을 판단한다.
  - 따라서 Key 값으로 `String`을 사용하면 이미 재정의 된 `hashCode()`와 `equals()`를 활용할 수 있다.
- 만약 개발자가 만든 클래스의 객체를 키로 사용할 경우엔 `hashCode()`와 `equals()`를 재정의 해야 한다

#### 15.4.2 `HashTable`

- Thread-safe 한 `Hashmap`이다

#### 15.4.3 `Properties`

- 키와 값의 타입을 `String`으로 제한한 컬렉션으로 주로 `*.properties` 파일을 읽을 때 사용된다.

### 15.5 검색 기능을 강화시킨 컬렉션

#### 15.5.1 이진 트리 구조

- 컬렉션 프레임워크에서 검색기능을 강화시킨 구현체를 제공할 때 기본적으로 내부에서 사용하는 구조이다.

#### 15.5.2 `TreeSet`

- 기존에 `Set` 인터페이스가 가진 메소드에 더하여, 검색기능이 강화된 메소드를 제공한다

| 메소드         | 설명                                            |
| -------------- | ----------------------------------------------- |
| `first()`      | 제일 낮은 객체를 리턴                           |
| `last()`       | 제일 높은 객체를 리턴                           |
| `lower(E e)`   | 주어진 객체보다 바로 아래 객체를 리턴           |
| `higher(E e)`  | 주어진 객체보다 바로 위 객체를 리턴             |
| `floor(E e)`   | 동등한 객체를 리턴 없으면 바로 아래 객체를 리턴 |
| `ceiling(E e)` | 동등한 객체를 리턴 없으면 바로 위 객체를 리턴   |
| `pollFirst()`  | 제일 낮은 객체를 리턴하고 제거                  |
| `pollLast()`   | 제일 높은 객체를 리턴하고 제거                  |

- 또한 `Set`컬렉션이 제공하는 `Iterator` 를 리턴하는 메소드에 더해서, 아래의 정렬관련 메소드를 제공한다.

| 리턴 타입         | 메소드                 | 설명                                    |
| ----------------- | ---------------------- | --------------------------------------- |
| `Iterator<E>`     | `descendingIterator()` | 내림차순으로 정렬된 `Iterator`를 리턴   |
| `NavigableSet<E>` | `descendingSet()`      | 내림차순으로 정렬된 `NavigableSet` 리턴 |

- `NavigableSet`은 `descendingSet()`이라는 동일한 이름의 정렬순서를 바꾸는 메소드를 가지고있다.

  - 따라서 `TreeSet`에 `descendingSet()`을 두번 호출하면 오름차순 정렬이 된다.

- 특정 객체를 기준으로 범위의 값들을 `NavigableSet`으로 반환하는 메소드도 존재한다.

  | 리턴 타입         | 메소드                                       | 설명                                                         |
  | ----------------- | -------------------------------------------- | ------------------------------------------------------------ |
  | `NavigableSet<E>` | `headSet(E e, boolean inculsive)`            | 주어진 객체보다 낮은 객체들 리턴, 2번째 파라미터가 `true`이면 |
  | `NavigableSet<E>` | `tailSet(E e, boolean inculsive)`            | 주어진 객체보다 높은 객체들 리턴, 2번째 파라미터가 `true`이면 |
  | `NavigableSet<E>` | `subSet(E e1, boolean b1, E e2, boolean b2)` | 주어진 객체 둘 사이의 값을 리턴, 2번째 4번째 파라미터로 포함여부 차이 |

#### 15.5.3 `TreeMap`

- `TreeMap`은 이진트리를 기반으로한 검색기능이 강화된 컬렉션이다.
- `TreeSet`과 유사한 형태의 메서드들을 제공하지만, 오로지 키 값으로 비교한다는 점만 차이가 있다.

#### 15.5.4 `Comparable`과 `Comparator`

- `TreeSet`과 `TreeMap`의 경우 자동 오름차순으로 정렬되는데, 유니코드를 기준으로 하는 `String`이나 정렬이 가능한 숫자타입을 제외하고, 다른 객체를 저장할 떄에는 `Comparable`을 구현한 객체여야만 한다.
  - 원시타입의 포장클래스인 `Integer`등은 모두 해당 인터페이스를 구현하고 있다.
- 개발자가 만든 클래스에서 `Comparable`을 구현하려면 아래의 메소드를 오버라이딩 해야 한다

| 리턴 타입 | 메소드           | 설명                                                         |
| --------- | ---------------- | ------------------------------------------------------------ |
| `int`     | `compareTo(T o)` | 주어진 객체와 같으면 0을 리턴<br/>주어진 객체보다 적으면 음수를 리턴<br/>주어진 객체보다 크면 양수를 리턴 |

- `Comparable`을 구현하지 않은 객체를 `TreeSet` 에 저장하려면 저장하는 순간에 `ClassCastException`이 발생한다.
  - 하지만 `TreeSet`이나 `TreeMap`을 생성할 때, **정렬자**를 제공하면 이를 방지할 수 있다.
- 정렬자는 `Comparator` 인터페이스를 구현한 객체로, 다음의 메소드를 재정의 해야만 한다

| 리턴 타입 | 메소드                | 설명                                                         |
| --------- | --------------------- | ------------------------------------------------------------ |
| `int`     | `compare(T o1, T o2)` | 둘이 동일하면 0을 리턴<br/>뒤의 값이 크면 음수를 리턴<br/>뒤의 값이 작으면 양수를 리턴 |

### 15.6 LIFO와 FIFO 컬렉션

- 선입선출과 후입선출을 구현한 컬렉션으로 자바는 `Stack` 클래스와 `Queue` 인터페이스를 제공한다.

#### 15.6.1 `Stack`

- LIFO의 구조를 구현하고 있는 클래스로 바로 사용할 수 있는 주요 메소드를 아래와 같이 제공한다.

| 메소드         | 설명                                     |
| -------------- | ---------------------------------------- |
| `push(E item)` | 주어진 객체를 스택에 넣는다              |
| `peek()`       | 맨 위 객체를 가져온다, 제거하지는 않는다 |
| `pop()`        | 맨 위 객체를 가져온다, 제거한다.         |

#### 15.6.2 `Queue`

- 스택과 달리 큐는 인터페이스로 되어있으며, 이를 구현한 클래스를 큐의 기능을 할 수 있도록 아래의 메소드를 정의하고 있다.

| 리턴 타입 | 메소드       | 설명                                           |
| --------- | ------------ | ---------------------------------------------- |
| `boolean` | `offer(E e)` | 주어진 객체를 넣는다                           |
| `E`       | `peek()`     | 객체 하나를 가져온다, 객제를 제거하지는 않는다 |
| `E`       | `poll()`     | 객체를 하나 가져온다, 객체를 제거한다.         |

- 대표적인 `Queue` 구현체는 `LinkedList`이다.

### 15.7 동기화된 컬렉션

- `Vetor`와 `HashTable`을 제외한 컬렉션 프레임워크의 컬렉션들은 멀티 스레드 환경에서 안전하지가 않다.
- `Collections` 유틸 클래스에는 멀티스레드 환경에서 안전하게 사용할 수 있도록 포장하는 메소드가 있다.

| 리턴 타입  | 메소드                           |
| ---------- | -------------------------------- |
| `List<T>`  | `synchronizedList(List<T> list)` |
| `Map<K,V>` | `synchronizedMap(Map<K,V> map)`  |
| `Set<T>`   | `synchronizedSet(Set<T> set)`    |

### 15.8 병렬 처리를 위한 컬렉션

- 동기화된 컬렉션은 Thread-safe는 보장하지만, 이로인해 병렬처리에서 속도 저하를 초래한다.
  - 자바가 `java.util.concurrent` 패키지에서  제공하는 병렬처리 전용 컬렉션을 사용하면 된다.
- 예를들어, `ConcurrentHashMap`을 사용하면, Thread-safe함과 동시에 병렬적으로 처리하게 할 수 있다.
  - 자바는 이를 부분잠금을 통해서 해결하는데, 컬렉션에서 사용되는 일부만 잠금처리를 하는 방식이다
- `ConcurrentLinkedQueue`의 경우 Lock-free 알고리즘을 구현하고 있다.
  - 여러개의 스레드가 동시 접근할 경우에도, 잠금없이 스레드 안전함을 보장해준다.