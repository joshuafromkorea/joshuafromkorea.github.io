---
layout: post
title: "이것이 자바다 self study - chapter 10"
date: 2018-12-16
categories:
---

드디어 자바의 예외처리를 다루는 챕터, 막상 이부분 공부하고 정리할 때만 해도 회사에서 일이 정말 없어서가지고 불만이 많았는데, 지금은 빨리 이거 올리고.. 회사일해야한다.. 공휴일인데..

---

## Chapter 10 예외 처리

Java는 예외를 클래스로 관리하며, 예외 발생시 JVM이 예외 객체를 생성하여 처리할 수 있도록 한다. 모든 예외 클래스는 `java.lang.Exception` 클래스를 상속 받는다. 예외는 크게 두가지로 구분 된다.

* 실행 예외: `Exception`을 상속받는 `java.lang.RuntimeException`을 상속 받는 예외
* 일반 예외: 실행 예외가 아닌 모든 예외, 체크 예외라고도 한다. 반드시 코드상에서 처리되어야 한다.

### 10.2 실행 예외

* 컴파일러가 체크를 하지 않으므로 코드 작성시 처리코드가 강제되지 않는다.
* 예외처리 코드가 없을 경우 해당 예외가 발생하면 프로그램은 곧바로 종료된다.

#### 10.2.1 `NullPointerException`

가장 많이 발생하는 실행 예외로, `null`값을 갖고 있는 참조 변수에 접근할 때 발생한다.

#### 10.2.2 `ArrayIndexOutOfBoundsException`

배열이 가진 인덱스 범위를 초과하여 접근할 경우 발생한다. 배열 사용시 항상 `length`값을 확인하여 접근하도록 분기처리를 하면 예방 할 수 있다.

#### 10.2.3 `NumberFormatException`

문자열 데이터를 숫자 데이터로 변경하는 경우에, 문자열에 숫자로 변환 불가능한 문자가 있을 경우 발생한다.

#### 10.2.4 `ClassCastException`

타입 강제 변환은 상위 하위클래스간이나, 구현 클래스와 인터페이스간에서 발생한다. 이러한 관계가 없는 경우에 억지로 타입변환을 시도할 경우에 발생한다. `instanceof` 연산자를 사용한 결과가 `true`일 때만 변환하도록 해서 예방할 수 있다.

### 10.3 예외 처리 코드

Java의 예외처리 코드는 `try`-`catch`-`finally` 블록을 사용한다. 해당 블록들은 생성자나 메소드 블록 내부에 존재하여서 해당 블록이 실행시 예외가 발생하면 처리를 진행한다. `try` 블록안에 예외가 발생 가능한 코드를 위치시키고, `catch` 블록은 발생 가능한 예외를 감지하여 일치하면 실행된다. 마지막으로 `finally` 블록은 예외 발생과 상관없이 항상 실행할 내용을 작성한다. `finally`블록은 `try`와 `catch`블록에서 `return`문을 사용하더라도 무조건 실행된다.

### 10.4 예외 종류에 따른 처리 코드

#### 10.4.1 다중 `catch`

`try` 블록내의 코드가 두 개 이상의 예외를 발생시킬 경우 `catch` 블록을 중첩하여 사용하면 된다. `try` 블록에서 예외가 발생할 경우 즉시 해당 블록의 코드 실행을 멈추고, 뒤따르는 `catch` 블록에서 일치하는 예외를 처리하는 블록을 찾아 처리 코드를 실행한다.

#### 10.4.2 `catch` 순서

다중 `catch` 블록을 사용할 경우에도 반드시 하나의 `catch` 블록만 실행되기 때문에, 항상 예외 클래스의 상속관계를 고려하여, 상위 타입을 더 아래에 배치하여야 한다. 예를 들어 `catch(Exception e)` 블록이 가장 상위에 위치한다면 뒤따르는 `catch` 블록은 절대로 실행되지 않는다.

#### 10.4.3 멀티 `catch`

Java 7에서 추가된 기능으로 하나의 `catch` 블록에서 다수의 예외를 처리할 수 있게 하는데, `catch` 블록의 괄호 `()`안에 예외를 `|` 를 사용하여 연결하면 된다.

```java
catch(ArrayIndexOutOfBoundsException | NumberFormatException e){
    //예외처리
}
```

### 10.5 자동 리소스 닫기

기존 Java 6까지는 리소스 객체(각종 입출력 스트림, 서버소켓, 소켓, 각종 채널)의 `close()`를 `finally` 블록에 사용할때, 다시한번 `try`와 `catch` 블록을 사용해서 처리했어야 했다. Java 7부터는 이를 대체하는 `try`-with-resource를 사용하면 `close()`를 사용할 필요가 없다. 방법은 다음과 같이 `try`블록에 사용하려는 리소스를 괄호 `()`안에서 선언 및 대입해주면 된다. 

```java
try(FileInputStream fileInputStream = new FileInputStream("file.txt")){
    fileInputStream.read();
} catch (Exception e) {
    //예외 처리 코드
}
```

`finally` 구문이 없어도 컴파일 에러도 발생하지 않으며,  수행이나 에러 발생시 `close()` 메소드가 자동적으로 호출된다. 이렇게 `try`-with-resource를 사용할 수 있는 리소스 객체는 반드시 `java.lang.AutoCloseable`인터페이스를 구현하고 있어야 한다.

### 10.6 예외 떠넘기기

생성자나 메소드 내부에서의 예외 처리는 `try`-`catch` 블록으로 처리하는 것이 기본이지만, 경우에 따라서 메소드를 호출한 클라이언트에게 예외처리를 일임할 수 있다. 이때 사용하는 키워드가 `throws` 이다. 메소드의 시그니처의 맨 마지막에 `throws` 키워드와 함께 위임하는 예외 클래스를 쉼표로 구분해서 나열해주면 된다.

```java
리턴타입 메소드명(매개변수, ...) thorws 예외1, 예외2 ... {
    
}
```

`thorws` 키워드 뒤에 `Exception` 클래스를 적어 모든 예외를 한번에 넘길 수도 있다. 이렇게 되면 해당 생성자나 메소드를 호출하는 쪽에서 반드시 예외를 `try`-`catch`블록으로 처리하던지, 아니면 `throws`를 사용해 다시 사용해 호출 하는 코드로 위임해야 한다. 그렇지 않으면 컴파일 에러가 발생한다. 이런식으로 프로그램이 시작되는 `main()` 메소드 까지 `throws`를 하게 되면 JVM이 예외의 내용을 콘솔에 출력하는 것으로 예외처리를 한다.

### 10.7 사용자 정의 예외와 예외 발생

자바 표준 API에서 제공하는 예외 클래스는 실제로 개발자가 구현하는 시스템 고유의 비즈니스 로직에 따른 예외를 다룰 수 없다. 이러한 애플리케이션 서비스와 직접적으로 연관된 예외들은 사용자가 직접 작성해 주어야 한다.

#### 10.7.1 사용자 정의 예외 클래스 선언

사용자 정의 예외는 클래스로 만드는데 어떤 예외를 상속 받느냐에 따라서 실행예외(`RuntimeException`)와 일반예외로 선언할 수 있다. 당연히 `Exception`을 상속받으면 일반예외로 선언되어 컴파일러가 체크하게 되고, `RuntimeException`을 상속하면 실행예외로 되어 체크하지 않게 된다.

관례적으로 직접 만든 예외클래스는 ~Exception으로 끝나는 이름으로 만들어 주며, 클래스가 포함할 수 있는 속성들을 가질 수 있지만 일반적으로는 두 개의 생성자를 선언한다. 하나는 default 생성자이고, 하나는 예외 발생 원인을 전달하기 위한 `String`타입의 매개변수를 가지는 생성자이다.

#### 10.7.2 예외 발생시키기

예외는 `throw`구문을 사용해서 의도적으로 코드에서 발생시킬 수도 있다. 예외 또한 클래스이므로 `new`구문을 사용해서 생성자를 호출해 초기화 해주어야 하며, 발생한 코드를 가진 메서드 내부에서 처리할수도 있지만, 메서드 시그니쳐에 `throws`키워드를 추가하여 호출한 쪽으로 예외처리를 위임할 수 있다.

### 10.8 예외 정보 얻기

`try`블록에서 발생한 예외는 `catch`블록의 매개변수에서 참조하므로, 해당 매개변수를 이용하여 예외 정보를 얻을 수 있다. 모든 예외는 `Exception`을 상속하고 있기 때문에, 해당 클래스가 가진 메소드들을 모든 예외 객체에서 호출가능하다. 일반적으로 `getMessage()`나 `printStackTrace()`를 사용한다. 전자의 경우엔 예외 클래스에서 정의된 메시지가 반환되며, 후자는 예외 발생 경로를 추적하는데 사용된다.
