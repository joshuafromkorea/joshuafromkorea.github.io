---
layout: post
title: "이것이 자바다 self study - chapter 5"
date: 2018-12-01
categories:
---
뭔가 복붙을 하면서 파일을 분리하고 있는데 5장부터 내용이 길어진 느낌이다. 이렇게 모아놓은 걸 한번에 올리니깐 예전에 중고등학생 시절 문학소년이 되겠다고 몇곳의 소설 연재사이트에서 글을 썼던 기억이 난다. 당시에 사이트마다 하는 대표적인 이벤트가 **연참 대전** 이었는데, 하루에 정해진 분량 이상의 글을 연속해서 많이 올리면 상을 주는 것이다. 물론 글빨이 받아서 술술 써내려가서 하루에도 두 세편씩 올리는 사람도 있지만, 블로그만 딱봐도 주저리주저리 하기 좋아하면서, 소설가가 되보겠다는 헛된 꿈을 가진 나에게 그런 능력은 없었다.

그래서 보통 당시 "업계"용어로 **폐관 수련**하여 **비축분**을 만들어놓고 연참대전이 올리면 막 글을 쏟아냈었다. 근데 사실 지금와서 생각해보면 뭔가 계획적으로 흐름을 생각하고 글을 끊은게 아니라 그냥 읽는 사람에게 압박을 줄만한 산문의 글을 연참대전 최소 규정에 맞춰서 하루에도 서너개씩 올려댔으니 더 읽을 맛이 안났을 것이다.

결국 글을 쓰는 작가는 못됬지만, 코드를 쓰는 코더는 되었으니... 당시에는 한번 쓴글은 다시보기가 싫어서 죽어도 하기싫었던 퇴고에 비해, 개발과제가 산더미인데 잘 돌아가는 코드의 리팩토링은 웃으면서 하는거 보니, 소설가를 꿈꾸던 과거의 나는 누구였을까?

## Chapter 5 참조 타입

### 5.1 데이터 타입 분류

Java의 데이터 타입은 크게 **원시타입**과 **참조타입**으로 분류한다.

* **원시 타입**: 실제 값을 변수 안에 저장, 자바 메모리의 stack 영역에 저장됨
* **참조 타입**: 실제 객체가 있는 heap 영역의 주소값을 변수에 저장(배열, 열거, 클래스, 인터페이스)

### 5.2 메모리 사용 영역

JVM이 운영체제에서 할당받은 메모리영역을 **Runtime Area**라고 하는데 해당 영역은 다음과 같이 구분된다.

#### 5.2.1 메소드(Method) 영역

코드에서 사용되는 클래스 (*.class)들을 클래스 로더로 읽어 런타임 상수풀, 필드데이터, 메소드 데이터, 메소드 코드 생성자 코드등을 분류해서 저장한다.. 모든 스레드가 공유하는 영역이다.

#### 5.2.2 힙(Heap) 영역

힙 영역은 객체와 배열이 생성되는 영역이다. 이 안의 객채와 배열은 JVM의 스택영역의 변수나 다른 객체의 필드에서 참조한다. 아무곳에서 참조되지 않는다면 Garbage Collector를 실행시켜 자동으로 제거한다.

#### 5.2.3 JVM 스택(Stack) 영역

* 각 스레드마다 하나씩 존재하며 스레드가 시작될 때 할당된다.
* 별도의 스레드를 생성하지 않으면 main 스레드만 존재하므로 하나만 존재한다.
* 메소드 호출시마다 **프레임(Frame)**이 추가(push)하고 종료시 제거(pop)한다.
* 프레임 내부에는 로컬 변수를 위한 스택이 있는데, 로컬 변수(메소드 내부 변수)도 push와 pop이 일어난다.

### 5.3 참조 변수의 `==`, `!=`연산

참조타입 변수가 피연산자일때의 비교 연산은 동일한 객체를 참조하고 있는지를 비교한다. 즉 참조하는 주소값이 다르다면 결과는 `true` 아닐 경우에는 `false`이다.

### 5.3 `null`과 `nullPointerException`

참조 타입의 변수는 힙 영역 객체를 참조하지 않는 다는 의미의 `null`값을 가질 수 있다. `null`로 초기화된 변수도 스택영역에 생성된다. 이런 `null`값을 가진 참조타입의 변수를 사용하는 경우 `NullPointerException`이 발생한다.

### 5.5 String 타입

문자열은 String 객체로 힙영역에 생성되고, 문자열 변수는 이를 참조한다. Java의 경우 문자열 리터럴이 동일하다면 동일한 문자열 객체를 참조하도록 되어있다. 하지만 `new String()`을 사용해 생성자를 호출할 경우 새로운 문자열 객체를 생성하게 된다.

### 5.6 배열타입

#### 5.6.1 배열이란?

같은 타입의 데이터만 연속적으로 저장할 수 있는 데이터 타입으로, 배열 이름뒤의 대괄호에 index를 사용하여 객체를 참조할 수 있다. 한번 생성되면 그 크기를 변하지 못하게 하기 때문에 배열 복사가 필요하다.

#### 5.6.2 배열 선언

`타입[] 변수;`, 혹은 `타입 변수[];`의 형태로 선언할 수 있다. 배열 변수는 참조 변수임으로 `null`로 초기화가 가능하다.

#### 5.6.2 값 목록으로 배열 생성

배열자체는 객체로 힙영역에 생성된다. 중괄호에 값을 넣는 방법으로 배열을 생성할 수 있다.

```java
데이터타입[] 변수 = {값0, 값1, 값2 ...};
```

이렇게 생성된 배열은 `변수[0]`과 같이 표현하여 접근 가능하며, 이 경우 `값0`이 참조된다. 동일하게 접근한 배열의 영역을 대입연산자의 좌측 피연산자로하면 값을 대입하여 바꿀 수 있다.

단, 배열변수를 선언함과 동시에 값 목록으로 배열을 생성하는 경우엔 `new 타입[]{값0, 값1, 값2 ...}`와 같은 방식으로 생성해주어야 한다. 그렇지 않을 경우 컴파일 에러가 발생한다.

#### 5.6.2 `new` 연산자로 배열 생성

당장 내부의 값은 없지만, 특정 길이를 가진 배열을 생성하고 싶다면 다음과 같이 생성할 수 있다.

```java
타입[] 변수 = new 타입[길이];
```

길이에는 정수타입의 자연수이고, `new`연산자의 경우 이미 배열변수가 선언된 후에도 가능하다. 또한 `new`연산자를 사용하면 배열은 자동적으로 기본 값으로 초기화된다. 각 배열의 초기 값은 다음과 같다.

| 분류            | 데이터타입                                             | 초기값                                |
| --------------- | ------------------------------------------------------ | ------------------------------------- |
| 기본 타입(정수) | byte[]<br />char[]<br />short[]<br />int[]<br />long[] | 0<br />'\u0000'<br />0<br />0<br />0L |
| 기본 타입(실수) | float[]<br />double[]                                  | 0.0F<br />0.0                         |
| 기본 타입(논리) | boolean[]                                              | false                                 |
| 참조 타입       | 클래스[]<br />인터페이스[]                             | null<br />null                        |

#### 5.6.5 배열 길이

배열에 저장할 수 있는 전체 항목의 수를 배열 길이라고 한다. 배열객체의 `length` 필드가 해당 값을 가지고 있으며 `배열변수.length`로 접근 가능하다. 해당 필드는 읽기 전용 필드로 값을 바꿀 수 없다.

#### 5.6.6 커맨드 라인 입력

Java 프로그램 실행을 위해 만든 `main()`의 경우 파라미터로  배열을`(String[] args)`받는이유는 다음과 같다.

```powershell
java 클래스명
```

위와 같이 클래스 이름으로 프로그램을 실행하면  JVM은 길이가 0인 `String` 배열을 생성하고, 이를 `main()`에 매개 값으로 전달 한다.

```powershell
java 클래스명 문자열0 문자열1 문자열2
```

위와 같이 실행했을 경우, 클래스 명 이후의 문자열들이 JVM이 생성한 배열에 담겨서 전달되며 메소드 내부에서 사용되는 것이다.

#### 5.6.7 다차원 배열

다음과 같은 코드로 다차원 배열을 만들 수 있다.

```java
타입[][] 변수명 = new 타입[2][3]
```

수학의 행렬과 동일하게 사용할 수 있으며, 다른 점은 일차원 배열이 서로 참조하는 구조로 다차원 배열을 만들기 때문에 계단식 구조도 가질 수 있다.

```java
int [][] scores = new int[2][];
scores[0] = new int[2]; // [][]
scores[1] = new int[3]; // [][][]

System.out.println(scores.length);		//2
System.out.println(scores[0].length);	//2
System.out.println(scores[1].length);	//3
```

#### 5.6.8 객체를 참조하는 배열

배열 생성시 타입에 원시타입이 아닌 참조타입을 사용하면, 배열의 항목에 객체의 주소 값을 가지게 된다.

#### 5.6.9 배열 복사

배열은 생성 후 크기 변경이 불가능 하기 때문에, 새로운 배열을 생성 후 이전 배열로 부터 항목 값을 복사한다. 이를 위해 `System.arraycopy()`를 사용하거나 `for`문으로 배열을 복사해야 한다.

#### 5.6.10 향상된 `for`문

Java5부터 배열 및 컬렉션 객체를 처리하기 위해 기존의 `for`문과 다른 향상된 `for`문을 제공한다.

```java
for(타입 변수 : 배열){ 실행문 }
```

타입 변수는 실행문 블록 안에서 사용가능하고, 배열의 값을 0번 인덱스부터 `length-1` 인덱스까지 읽어 타입변수에 대입 후 실행문을 반복한다.

### 5.7 열거 타입

한정된 값만 가진 데이터 타입을 구현한 것이 열거 타입으로, 열거 상수 중에서 하나의 상수를 저장하는 데이터 타입이다.

#### 5.7.1 열거 타입 선언

열거 타입을 `pulbic`으로 만들기 위해선 별도의 *.java 파일을 생성해야 한다. 클래스와 동일하게 첫 문자를 대문자로 한다. 아래는 Week.java 파일안에 열거 타입 선을을 한 예

```java
public enum Week{
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY,
    SUNDAY
}
```

열거 타입의 이름은 소스 파일명과 대소문자가 모두 일치해야 하며, 중괄호 내부의 열거 상수는 열거타입의 값으로 사용되는데, 모두 대문자로 작성한다. 또한 두 개이상의 단어일 경우 공백을 `_`로 대체하는게 관례이다.

열거 타입을 변수로 선언할 때는 일반적인 클래스 선언과 동일하지만, 받을 수 있는 값은 해당 타입 내부에 선언된 열거 상수로 제한된다. 또한 열거타입도 참조타입이기에 `null`을 저장할 수도 있다.

```java
Week today;
Week tomorrow;

today = Week.SATURDAY;
tomorrow = Week.SUNDAY;

Week birthday = null;
```

열거 상수는 그 자체로 객체이기에 힙 영역에 생성된다. 별도의 코드로 생성하지 않아도 `public enum Week{}`내부에 선언된 열거 상수 모두가 객체로 생성되어 있으며, 이를 참조하는 상수는 JVM 메소드 영역에 존재한다.

즉, `Week.SUNDAY`라는 상수는 메소드 영역에서 힙영역의 `SUNDAY`열거객체를 참조하고 있으며, `today`라는 변수는 스택 영역에서 동일한 열거객체를 참조하고 있다. 이를 `==`연산자로 확인 가능하다.

```java
System.out.println(Week.SATURDAY==today); //true
```

#### 5.7.3 열거 객체의 메소드

열거 객체는 `java.lang.Enum`을 컴파일시에 상속하는데, 해당 클래스에는 아래와 같은 메소드가 있다.

##### `name()` 메소드

```java
public final String name() { return name; }
```

열거 상수를 정의할 때 사용한 상수 이름을 `String`으로 리턴한다.

##### `ordinal()` 메소드

```java
public final int ordinal() { return ordinal; }
```

전체 열거 객체 중 해당 객체의 순번을 알려준다.타입을 정의할 때 순서대로 0번부터 부여된다.

##### `compareTo()`메소드

```java
public final int compareTo(E o) {
    Enum other = (Enum)o;
    Enum self = this;
    if (self.getClass() != other.getClass() && // optimization
        self.getDeclaringClass() != other.getDeclaringClass())
        throw new ClassCastException();
    return self.ordinal - other.ordinal;
}
```

파라미터로 받은 같은 타입의 열거 객체와 자신의 순번을 비교해서 **객체 자신**에서 **파라미터 열거객체** 순번을 뺀 값을 보여준다. 파라미터가 더 `ordinal`값이 작을 경우 양수 반환

##### `valueOf()` 메소드

```java
public static <T extends Enum<T>> T valueOf(Class<T> enumType,
                                            String name) {
    T result = enumType.enumConstantDirectory().get(name);
    if (result != null)
        return result;
    if (name == null)
        throw new NullPointerException("Name is null");
    throw new IllegalArgumentException(
        "No enum constant " + enumType.getCanonicalName() + "." + name);
}
```

파라미터로 주어지는 문자열과 동일한 문자열을 열거상수로 가지는 열거객체를 반환한다.

##### `values()`메소드

```java
 * implicit {@code public static T[] values()} method of that
 * type.
```

`values()`메소드는 묵시적으로만 선언되어있다. 이렇게 묵시적으로 선언된 메소드들은 컴파일 타임에 해당 객체에 추가되고 런타임에서 사용 가능하다. `values()`메소드는 열거 타입의 모든 객체로 배열을 만들어 해당 배열을 반환한다.
