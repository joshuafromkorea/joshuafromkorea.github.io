---
layout: post
title: "이것이 자바다 self study - chapter 7"
date: 2018-12-07
categories:
---
분명히 1권을 다 마무리지어서 동기들에게 배포했는데, 회사에서 대부분의경우에 공부하고 작성해서 그런지, 개인 랩탑에는 최신버젼 markdown이 없다. 그래서 오늘은 7장까지밖에 못 올릴 것 같다. 사실 매일매일 안올렸던게 github 블로그가 뭔가 바로바로 적용이 안되서였는데. 일단 7장까지 올리고 한번 push 해봐야겠다.

난 인문학의 꽃인 역사학을 전공한 개발자라서 제대로된 개발 공부라는 것을 학원에서 자바로 시작했는데, 당시에 상속이라는 개념은 정말 이해하기 어려웠었다. 하긴 자바에서 말하는 클래스와 객체가 무엇인지이해 못하는 상황에서 상속을 이해할수가 있을까. 갑자기 아주 최근에 인터페이스라는 것을 왜 사용하는지 깨닫게 되고 나서부터 개발하는 재미가 올랐는데, 이 self-study를 하면서 상속과 인터페이스를 한 차원 높은 레벨(원래 바닥 수준이어서 그다지 높은 건 아니지만)로 이해하게 되면서 자바라는 언어에 더 빠지게 되었고, 자바 개발자라고 소개할 수 있게 되었다.

## Chapter 7 상속

### 7.1 상속 개념

객체 지향 프로그래밍에서 **상속**이란 이미 개발된 클래스를 재사용해서 새로운 클래스를 만드는 기능을 말한다. 일반적으로 상속을 통해 이뤄진 클래스의 관계는 일반적으로 **부모**, **자식** 클래스로 부르는데, 자식클래스는 부모 클래스의 필드와 메소드를 물려받는다.

다만, **`private`** 접근제한자를 가진 부모 클래스의 필드와 메소드는 상속 대상에서 제외된다. 또한 만약 부모와 자식이 별도의 패키지의 존재할 경우 **`(default)`** 접근제한자를 갖는 필드와 메소드도 상속에서 제외된다.

### 7.2 클래스 상속

아래와 같은 방법 자식클래스를 작성하면 부모 클래스를 상속한다.

```java
class child extends parent{
    
}
```

자바는 **다중 상속**을 **금지** 한다.

### 7.3 부모 생성자 호출

자바에서 자식 객체를 생성하는 것은 곧 부모 객체를 heap 영역에 생성하는 것을 의미한다. 따라서 자식 객체의 생성자는 반드시 부모객체의 생성자를 호출(`super()`)하는데 이 작업을 컴파일러가 진행해준다.

* 자식 객체의 생성자가 명시되지 않았다면, 디폴트 생성자를 만들어 내부에서 `super()`를 호출
* 자식 객체의 생성자가 명시되었다면, 매개변수값이 일치하는 부모 생성자 호출
* 부모 클래스의  매개변수 값이 있는 생성자만 있을시, 컴파일 에러
  *  **자식에서 명시적으로 호출해야함!!**

### 7.4 메소드 재정의

#### 7.4.1 메소드 재정의(`@Override`)

부모 클래스의 메소드를, 자식클래스에서 재정의 하는 것을 말한다, 이경우에는 자식 객체에서 해당 메소드를 호출하면 오버라이딩된 메소드가 호출된다. 다음과 같은 규칙이 있다.

* 부모의 메소드와 동일한 시그니처를 가져야 한다
* 접근 제한을 더 강하게 오버라이딩 할 수 없다
* 새로운 예외를 `throws`할 수 없다.

#### 7.4.2 부모 메소드 호출(`super`)

자식 클래스에서 오버라이딩된 부모메소드를 호출해야 할때는 `super.메소드이름()`으로 호출 할 수 있다.

### 7.5 `final` 클래스와 `final`메소드

#### 7.5.1 상속할 수 없는 `final`클래스

클래스 선언시 `final` 키워드를 붙여 선언하면 해당 클래스는 상속할 수 없다.

#### 7.5.2 오버라이딩 할 수 없는 `final`메소드

메소드 선언시 `final` 키워드를 붙이면, 오버라이딩할 수 없다.

### 7.6 `protected`접근 제한자

`protected`  접근 제한자는 다른 패키지에서 자식 클래스에게만 접근을 허용할 때 사용하는 접근제한자이다.

### 7.7 타입 변환과 다형성

**다형성**이란 같은 타입이지만 실행 결과가 다양한 객체를 이용하는 성질을 말한다. 다형성을 위해 자바는 부모 클래스로의 타입변환을 허용한다. 

#### 7.7.1 자동 타입 변환(Promotion)

부모 클래스 타입으로 선언한 변수에, 자식클래스 타입의 객체를 대입할 때 자동타입 변환이 일어난다. 단 이경우에는 **부모 클래스에 선언**된 필드와 메소드만 접근이 가능하다. 단 부모와 자식간에 동일 메소드가 존재하고 오버라이딩이 된 경우에는 자식 객체의 메소드가 호출된다.

#### 7.7.2 필드의 다형성

**자동 타입 변환**은 주로 클래스 타입을 필드로 사용할 때, 객체 지향 프로그래밍에서 상속관계의 객체를 교체하더라도 코드의 변화없이 다양한 결과가 나오도록 하기 위한 **필드의 다형성**을 위해 필요하다. 필드 타입에는 변화가 없지만 실행 도중에 어떤 객체를 필드로 저장하느냐에 따라 실행결과가 달라질 수 있는 것이다. 

#### 7.7.4 매개 변수의 다형성

**자동 타입 변환**은 필드보다 주로 메소드 호출시 부모 객체타입의 매개변수에 자식 타입의 매개변수로 호출하는 방법으로 사용할 때 일어난다.

#### 7.7.5 강제 타입 변환(Casting)

자동 타입 변환된 자식 객체는 부모 타입에 선언된 필드와 메소드만 사용가능하다. 단 이를 다시 자식 타입으로 강제 변환 해주면 자식 타입의 필드와 메소드를 사용할 수 있다. 캐스팅 연산자 `( )`안에 변환하려는 자식타입 이름을 넣으면 된다.

```java
Parent parent = new Child(); //자동 타입 변환
Child childe = (Child) parent; //강제 타입 변환
```

#### 7.7.6 객체 타입 확인(`instanceof`)

부모 타입으로 선언된 변수가 참조하는 객체가 실제로 자식객체인지 부모객체인지 확인 하는 것은 `instanceof`연산자를 통해서 진행한다.

```java
boolean result = 객체(변수) instanceof 타입(클래스명)
```

강제 타입 변환이 필요할 경우 `instanceof`연산자의 리턴값이 `true`일 경우 진행하면 안전하다. 만약 `false`인 경우에 강제 타입 변환을 하면 `ClassCastException`이 발생한다.

### 7.8 추상 클래스

#### 7.8.1 추상 클래스의 개념

객체를 생성할 수 있는 클래스들을 "실체 클래스"라고 할때, 이들 사이에서 공통적인 특성을 추출해서 선언한 클래스를 추상 클래스라고 한다. 추상클래스와 실체클래스들은 상속의 관계를 가지게 된다. 추상클래스는 공통되는 필드와 메소드를 추출해서 만들었기 때문에 직접 생성해서 사용할 수 없다. 

#### 7.8.2 추상 클래스의 용도

##### 1. 실체 클래스들의 공통된 필드와 메소드의 이름을 통일

유사 한 성질과 기능을 가진 필드와 메소드를 여러 개발자가 만들 경우 이를 통일할 수 있다.

##### 2. 실체 클래스를 작성할 떄 시간을 절약

공통적인 필드와 메소드가 추상 클래스에 존재하면, 실체 클래스에서는 상속을 통해 이를 재사용할 수 있다.

#### 7.8.3 추상 클래스 선언

클래스 선언시 접근제한자와 `class`사이에 `abstract`키워드를 사용하면 된다.

```java
public abstract class 클래스명{

}
```

추상 클래스에도 필드, 생성자, 메소드 선언을 할 수 있다. `new`연산자로 생성자 호출은 불가능 하지만 자식 클래스에서 `super(...)`를 통한 호출이 일어나므로 반드시 필요하다.

#### 7.8.4 추상 메소드와 오버라이딩

실체 클래스들의 메소드의 선언은 동일하지만, 실행내용이 달라야 하는 경우에는 추상클래스에서 **추상메소드를 선언**하면 된다. 이렇게 선언된 추상메소드는 추상클래스를 상속받는 클래스에서 반드시 오버라이딩 되어야 하는데, 오버라이딩 하지 않으면 컴파일 에러가 발생한다. 메소드 시그니쳐의 접근제한자와 리턴 값 사이에 `abstract` 키워드를 넣어주고, 세미콜론(`;`)을 붙여 선언한다.

```java
public abstract void method1();
```

이렇게 생성된 추상메소드는 자식 클래스에서 반드시 오버라이딩 되어야 하며, 각 자식클래스마다 다르게 기능하여 메소드 다형성을 적용할 수 있다.
